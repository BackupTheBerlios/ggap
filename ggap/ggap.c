/* This file has been generated with opag 0.8.0.  */
/*
 *   ggap.opag
 *
 *   Copyright (C) 2004-2006 by Yevgen Muntyan <muntyan@math.tamu.edu>
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   See COPYING file that comes with this distribution.
 */

#line 15 "../../../ggap/ggap.opag"

#include "config.h"
#include "gapapp.h"
#include "ggap-ui.h"
#include "ggap-credits.h"
#include "ggap-i18n.h"
#include "ggapfile.h"
#include "mooutils/mooutils-fs.h"
#include "mooutils/mooutils-misc.h"
#include "mooutils/moostock.h"
#include <gtk/gtk.h>
#include <glib/gstdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <locale.h>


#define DEFAULT_NEW_INSTANCE FALSE


int _ggap_parse_options (const char *const program_name,
                         const int         argc,
                         char **const      argv);

/********************************************************
 * command line parsing code generated by Opag
 * http://www.zero-based.org/software/opag/
 */
#line 43 "ggap.c"
#ifndef STR_ERR_UNKNOWN_LONG_OPT
# define STR_ERR_UNKNOWN_LONG_OPT   "%s: unrecognized option `--%s'\n"
#endif

#ifndef STR_ERR_LONG_OPT_AMBIGUOUS
# define STR_ERR_LONG_OPT_AMBIGUOUS "%s: option `--%s' is ambiguous\n"
#endif

#ifndef STR_ERR_MISSING_ARG_LONG
# define STR_ERR_MISSING_ARG_LONG   "%s: option `--%s' requires an argument\n"
#endif

#ifndef STR_ERR_UNEXPEC_ARG_LONG
# define STR_ERR_UNEXPEC_ARG_LONG   "%s: option `--%s' doesn't allow an argument\n"
#endif

#ifndef STR_ERR_UNKNOWN_SHORT_OPT
# define STR_ERR_UNKNOWN_SHORT_OPT  "%s: unrecognized option `-%c'\n"
#endif

#ifndef STR_ERR_MISSING_ARG_SHORT
# define STR_ERR_MISSING_ARG_SHORT  "%s: option `-%c' requires an argument\n"
#endif

#define STR_HELP_GAP_CMD "\
  -g, --gap-cmd=COMMAND    GAP command line\n"

#define STR_HELP_EDITOR "\
  -e, --editor             Do not start GAP automatically\n"

#define STR_HELP_PURE_EDITOR "\
  -E, --pure-editor        Do not enable any GAP stuff\n"

#define STR_HELP_NEW_APP "\
  -n, --new-app            Run new instance of application\n"

#define STR_HELP_FANCY "\
      --fancy              Fancy mode\n"

#define STR_HELP_EXTRACT "\
  -x, --extract            =FILE Unpack saved worksheet file\n"

#define STR_HELP_LOG "\
  -l, --log[=FILE]         Show debug output or write it to FILE\n"

#define STR_HELP_VERSION "\
      --version            Display version information and exit\n"

#define STR_HELP_HELP "\
  -h, --help               Display this help text and exit\n"

#define STR_HELP "\
  -g, --gap-cmd=COMMAND    GAP command line\n\
  -e, --editor             Do not start GAP automatically\n\
  -E, --pure-editor        Do not enable any GAP stuff\n\
  -n, --new-app            Run new instance of application\n\
      --fancy              Fancy mode\n\
  -x, --extract            =FILE Unpack saved worksheet file\n\
  -l, --log[=FILE]         Show debug output or write it to FILE\n\
      --version            Display version information and exit\n\
  -h, --help               Display this help text and exit\n"

/* Set to 1 if option --gap-cmd (-g) has been specified.  */
char _ggap_opt_gap_cmd;

/* Set to 1 if option --editor (-e) has been specified.  */
char _ggap_opt_editor;

/* Set to 1 if option --pure-editor (-E) has been specified.  */
char _ggap_opt_pure_editor;

/* Set to 1 if option --new-app (-n) has been specified.  */
char _ggap_opt_new_app;

/* Set to 1 if option --fancy has been specified.  */
char _ggap_opt_fancy;

/* Set to 1 if option --extract (-x) has been specified.  */
char _ggap_opt_extract;

/* Set to 1 if option --log (-l) has been specified.  */
char _ggap_opt_log;

/* Set to 1 if option --version has been specified.  */
char _ggap_opt_version;

/* Set to 1 if option --help (-h) has been specified.  */
char _ggap_opt_help;

/* Argument to option --gap-cmd (-g).  */
const char *_ggap_arg_gap_cmd;

/* Argument to option --log (-l), or a null pointer if no argument.  */
const char *_ggap_arg_log;

/* Parse command line options.  Return index of first non-option argument,
   or -1 if an error is encountered.  */
int _ggap_parse_options (const char *const program_name, const int argc, char **const argv)
{
  static const char *const optstr__gap_cmd = "gap-cmd";
  static const char *const optstr__editor = "editor";
  static const char *const optstr__pure_editor = "pure-editor";
  static const char *const optstr__new_app = "new-app";
  static const char *const optstr__fancy = "fancy";
  static const char *const optstr__extract = "extract";
  static const char *const optstr__version = "version";
  static const char *const optstr__help = "help";
  int i = 0;
  _ggap_opt_gap_cmd = 0;
  _ggap_opt_editor = 0;
  _ggap_opt_pure_editor = 0;
  _ggap_opt_new_app = 0;
  _ggap_opt_fancy = 0;
  _ggap_opt_extract = 0;
  _ggap_opt_log = 0;
  _ggap_opt_version = 0;
  _ggap_opt_help = 0;
  _ggap_arg_gap_cmd = 0;
  _ggap_arg_log = 0;
  while (++i < argc)
  {
    const char *option = argv [i];
    if (*option != '-')
      return i;
    else if (*++option == '\0')
      return i;
    else if (*option == '-')
    {
      const char *argument;
      size_t option_len;
      ++option;
      if ((argument = strchr (option, '=')) == option)
        goto error_unknown_long_opt;
      else if (argument == 0)
        option_len = strlen (option);
      else
        option_len = argument++ - option;
      switch (*option)
      {
       case '\0':
        return i + 1;
       case 'e':
        if (strncmp (option + 1, optstr__editor + 1, option_len - 1) == 0)
        {
          if (option_len <= 1)
            goto error_long_opt_ambiguous;
          if (argument != 0)
          {
            option = optstr__editor;
            goto error_unexpec_arg_long;
          }
          _ggap_opt_editor = 1;
          break;
        }
        if (strncmp (option + 1, optstr__extract + 1, option_len - 1) == 0)
        {
          if (option_len <= 1)
            goto error_long_opt_ambiguous;
          if (argument != 0)
          {
            option = optstr__extract;
            goto error_unexpec_arg_long;
          }
          _ggap_opt_extract = 1;
          break;
        }
        goto error_unknown_long_opt;
       case 'f':
        if (strncmp (option + 1, optstr__fancy + 1, option_len - 1) == 0)
        {
          if (argument != 0)
          {
            option = optstr__fancy;
            goto error_unexpec_arg_long;
          }
          _ggap_opt_fancy = 1;
          break;
        }
        goto error_unknown_long_opt;
       case 'g':
        if (strncmp (option + 1, optstr__gap_cmd + 1, option_len - 1) == 0)
        {
          if (argument != 0)
            _ggap_arg_gap_cmd = argument;
          else if (++i < argc)
            _ggap_arg_gap_cmd = argv [i];
          else
          {
            option = optstr__gap_cmd;
            goto error_missing_arg_long;
          }
          _ggap_opt_gap_cmd = 1;
          break;
        }
        goto error_unknown_long_opt;
       case 'h':
        if (strncmp (option + 1, optstr__help + 1, option_len - 1) == 0)
        {
          if (argument != 0)
          {
            option = optstr__help;
            goto error_unexpec_arg_long;
          }
          _ggap_opt_help = 1;
          return i + 1;
        }
        goto error_unknown_long_opt;
       case 'l':
        if (strncmp (option + 1, "og", option_len - 1) == 0)
        {
          _ggap_arg_log = argument;
          _ggap_opt_log = 1;
          break;
        }
        goto error_unknown_long_opt;
       case 'n':
        if (strncmp (option + 1, optstr__new_app + 1, option_len - 1) == 0)
        {
          if (argument != 0)
          {
            option = optstr__new_app;
            goto error_unexpec_arg_long;
          }
          _ggap_opt_new_app = 1;
          break;
        }
        goto error_unknown_long_opt;
       case 'p':
        if (strncmp (option + 1, optstr__pure_editor + 1, option_len - 1) == 0)
        {
          if (argument != 0)
          {
            option = optstr__pure_editor;
            goto error_unexpec_arg_long;
          }
          _ggap_opt_pure_editor = 1;
          break;
        }
        goto error_unknown_long_opt;
       case 'v':
        if (strncmp (option + 1, optstr__version + 1, option_len - 1) == 0)
        {
          if (argument != 0)
          {
            option = optstr__version;
            goto error_unexpec_arg_long;
          }
          _ggap_opt_version = 1;
          return i + 1;
        }
       default:
       error_unknown_long_opt:
        fprintf (stderr, STR_ERR_UNKNOWN_LONG_OPT, program_name, option);
        return -1;
       error_long_opt_ambiguous:
        fprintf (stderr, STR_ERR_LONG_OPT_AMBIGUOUS, program_name, option);
        return -1;
       error_missing_arg_long:
        fprintf (stderr, STR_ERR_MISSING_ARG_LONG, program_name, option);
        return -1;
       error_unexpec_arg_long:
        fprintf (stderr, STR_ERR_UNEXPEC_ARG_LONG, program_name, option);
        return -1;
      }
    }
    else
      do
      {
        switch (*option)
        {
         case 'E':
          _ggap_opt_pure_editor = 1;
          break;
         case 'e':
          _ggap_opt_editor = 1;
          break;
         case 'g':
          if (option [1] != '\0')
            _ggap_arg_gap_cmd = option + 1;
          else if (++i < argc)
            _ggap_arg_gap_cmd = argv [i];
          else
            goto error_missing_arg_short;
          option = "\0";
          _ggap_opt_gap_cmd = 1;
          break;
         case 'h':
          _ggap_opt_help = 1;
          return i + 1;
         case 'l':
          if (option [1] != '\0')
          {
            _ggap_arg_log = option + 1;
            option = "\0";
          }
          else
            _ggap_arg_log = 0;
          _ggap_opt_log = 1;
          break;
         case 'n':
          _ggap_opt_new_app = 1;
          break;
         case 'x':
          _ggap_opt_extract = 1;
          break;
         default:
          fprintf (stderr, STR_ERR_UNKNOWN_SHORT_OPT, program_name, *option);
          return -1;
         error_missing_arg_short:
          fprintf (stderr, STR_ERR_MISSING_ARG_SHORT, program_name, *option);
          return -1;
        }
      } while (*++option != '\0');
  }
  return i;
}
#line 57 "../../../ggap/ggap.opag"
/* end of generated code
 ********************************************************/


static void usage (void)
{
    g_print ("Usage: %s [OPTIONS] [FILES]\n", g_get_prgname ());
    g_print ("Options:\n");

    g_print ("%s", STR_HELP_GAP_CMD);
    g_print ("%s", STR_HELP_EDITOR);
    g_print ("%s", STR_HELP_PURE_EDITOR);
    g_print ("%s", STR_HELP_NEW_APP);
    g_print ("%s", STR_HELP_FANCY);
    g_print ("%s", STR_HELP_EXTRACT);
    g_print ("%s", STR_HELP_LOG);
    g_print ("%s", STR_HELP_VERSION);
    g_print ("%s", STR_HELP_HELP);
}

static void version (void)
{
    g_print ("ggap %s\n", GGAP_VERSION);
}


static void
push_appdir_to_path (void)
{
#ifdef __WIN32__
    char *appdir;
    const char *path;
    char *new_path;

    appdir = moo_win32_get_app_dir ();
    g_return_if_fail (appdir != NULL);

    path = g_getenv ("Path");

    if (path)
        new_path = g_strdup_printf ("%s;%s", appdir, path);
    else
        new_path = g_strdup (appdir);

    g_setenv ("Path", new_path, TRUE);

    g_free (new_path);
    g_free (appdir);
#endif
}

static void
extract_file (const char *filename)
{
    GError *error = NULL;
    char *text = NULL;
    gsize text_len = 0;
    char *workspace = NULL;

    if (g_file_test ("worksheet.xml", G_FILE_TEST_EXISTS))
    {
        g_printerr ("File worksheet.xml already exists\n");
        exit (EXIT_FAILURE);
    }

    if (g_file_test ("workspace", G_FILE_TEST_EXISTS))
    {
        g_printerr ("File workspace already exists\n");
        exit (EXIT_FAILURE);
    }

    if (!ggap_file_unpack (filename, &text, &text_len, &workspace, &error))
    {
        if (error)
            g_printerr ("%s\n", error->message);
        else
            g_printerr ("Failed\n");
        exit (EXIT_FAILURE);
    }

    if (g_rename (workspace, "workspace") != 0)
    {
        perror ("rename");
        exit (EXIT_FAILURE);
    }

    if (!g_file_set_contents ("worksheet.xml", text, text_len, &error))
    {
        g_printerr ("%s\n", error->message);
        exit (EXIT_FAILURE);
    }
}

G_GNUC_NORETURN static void
extract_files (char **files)
{
    while (*files)
        extract_file (*files++);
    exit (EXIT_SUCCESS);
}

int main (int argc, char *argv[])
{
    MooApp *app;
    int opt_remain;
    char **files;
    int retval;
    gboolean new_instance;

#ifdef ENABLE_NLS
    bindtextdomain (GETTEXT_PACKAGE, moo_get_locale_dir ());
#ifdef HAVE_BIND_TEXTDOMAIN_CODESET
    bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
#endif
#endif

    g_thread_init (NULL);
    gdk_threads_init ();
    gdk_threads_enter ();

    gtk_init (&argc, &argv);

    opt_remain = _ggap_parse_options (g_get_prgname (), argc, argv);

    if (opt_remain < 0)
    {
        usage ();
        return EXIT_FAILURE;
    }

    if (_ggap_opt_help)
    {
        usage ();
        return EXIT_SUCCESS;
    }
    else if (_ggap_opt_version)
    {
        version ();
        return EXIT_SUCCESS;
    }

    if (_ggap_opt_log)
    {
        if (_ggap_arg_log)
            moo_set_log_func_file (_ggap_arg_log);
        else
            moo_set_log_func_window (TRUE);
    }

    if (_ggap_opt_extract)
        extract_files (argv + opt_remain);

    if (_ggap_opt_new_app)
        new_instance = TRUE;
    else
        new_instance = DEFAULT_NEW_INSTANCE;

    GAP_APP_EDITOR_MODE = _ggap_opt_pure_editor != 0;
    files = moo_filenames_from_locale (argv + opt_remain);

    push_appdir_to_path ();

    app = g_object_new (GAP_TYPE_APP,
                        "argv", argv,
                        "short-name", "ggap",
                        "full-name", "GGAP",
                        "version", VERSION,
                        "description", "GGAP is a front end for GAP",
                        "run-input", TRUE,
                        "default-ui", GGAP_UI,
                        "logo", "ggap",
                        "credits", THANKS,

//                         "gap-cmd-line", _ggap_arg_gap_cmd,
                        "editor-mode", (gboolean) _ggap_opt_editor,
                        "fancy", (gboolean) _ggap_opt_fancy,

                        NULL);

    if ((!new_instance && moo_app_send_files (app, files, 0, 0, NULL, 0)) ||
          !moo_app_init (app))
    {
        gdk_notify_startup_complete ();
        g_strfreev (files);
        g_object_unref (app);
        return EXIT_SUCCESS;
    }

    if (files && *files)
        moo_app_open_files (app, files, 0, 0, 0);

    g_strfreev (files);

    retval = moo_app_run (app);

    g_object_unref (app);
    gdk_threads_leave ();
    return retval;
}


#if defined(__WIN32__) && !defined(__GNUC__)

#include <windows.h>

int __stdcall
WinMain (HINSTANCE hInstance,
         HINSTANCE hPrevInstance,
         char     *lpszCmdLine,
         int       nCmdShow)
{
	return main (__argc, __argv);
}

#endif
